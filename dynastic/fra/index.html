<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8"> 
		<link rel="stylesheet" type="text/css" href="/static/styles/styles.css">
		<link rel="stylesheet" type="text/css" href="/static/styles/highlight.css">
		<title>Le Premier Article - Foobuzz</title>
	</head>
	
	<body>
	<div id="main_wrapper">
	
		<header>
			<div id="head_text_wrapper">
				<div id="head_text_bro"></div>
				<div id="head_text">
					<h1><a href="/">Foobuzz</a></h1>
					<p>Programming and other stuff</p>
				</div>
			</div>
		</header>
		
		<nav>
			<ul id="navigation">
				<li><a href="/">Front</a></li><!--
			 --><li><a href="/archives">Archives</a></li><!--
			 --><li><a href="/about">About</a></li>
			</ul>

		 	<ul id="networking">
				<li><a href="https://twitter.com/_foobuzz">Twitter</a></li>
			</ul>
		</nav>
		
		<div id="main">
		
			<div id="content">

				

<article>

	<div class="entete">by Valentin, <span title="2015-06-04T12:33:00Z">June 04 2015</span>, in
		
		<a href="/cat/meta">Meta</a>, 
		
		<a href="/cat/python">Python</a>
		
	</div>

	<div class="i18n">
		
		Langue : <img src="/static/fr.png" alt="français" title="français"> | <a href="/dynastic" title="Lire en anglais">Read in English</a>
		
	</div>

	<h1><a href="/dynastic">Le Premier Article</a></h1>

	<p>Bienvenue sur mon blog dont vous êtes en train de lire le premier article ! J'y parlerai essentiellement d'informatique et des projets que je tiens dans ce domaine, mais si l'envie me prend de parler d'autre choses je ne me priverai pas. En guise de premier article, je vais justement expliquer comment est fait mon blog.</p>
<p>Comme vous l'avez peut-être remarqué, il est hébergé sur <a href="https://pages.github.com/">GitHub Pages</a> et est donc purement statique. Pour ceux qui ne connaissent pas, lorsque vous créez un repot avec le nom {votre_username}.github.io sur GitHub, ce dernier crée automatiquement un site web statique avec cette adresse, si toutefois il existe un index.html à la racine du repo.</p>
<p>Il existe de nombreux générateurs de sites statiques, c'est-à-dire des programmes qui à partir de données (des articles écrit dans des fichiers texte utilisant le format <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a> généralement) et de templates, génèrent tout le contenu du site. Celui qui vient avec GitHub Pages s'appelle Jekyll et est codé en Ruby. Il y en a aussi un grand nombre en Python. Mais pour ce blog j'ai préféré écrire mon propre script artisanal, en Python.</p>
<h2>Dynastic</h2>
<p>J'ai appelé mon script Dynastic (ça sonne prétentieux pour quelque chose d'aussi simple). Il s'agit d'un mot-valise entre <em>dynamic</em> et <em>static</em>. Pour un site dynamique, on définit généralement une liste d'URIs, à chacune desquelles on associe un <em>handler</em>, c'est-à-dire une fonction ou une classe qui retourne le contenu de la page web qui sera délivrée à l'URI en question. Généralement, des parties de l'URI sont variables : ces variables seront passées au handler pour que ce dernier génère la page appropriée.</p>
<p>Dynastic marche comme ça aussi. La seule différence est que comme ce n'est pas dynamique, il faut définir pour chaque variable une liste des valeurs possibles pour cette variable.</p>
<h3>Exemple simple</h3>
<p>Imaginons par exemple qu'on veuille générer un site très simple : il possède N pages numérotée de 0 à N-1. La page k affiche "Hello, I'm page k" et possède un lien "Next page" (si elle existe) qui permet d'aller à la page k+1 et un lien "Previous page" (si elle existe) pour aller à la page k-1. La page d'accueil présente une liste de liens vers toutes les pages. La page d'accueil se trouve à la racine du site et possède donc l'URI '/' tandis qu'une page k se trouve à l'URI '/page/k'</p>
<p>Voici comment on peut définir ces URIs :</p>
<div class="codehilite"><pre class="source"><code><span class="n">routes</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;/&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">main</span><span class="p">,</span> <span class="p">{}),</span>
    <span class="s">&#39;/page/{page}&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">permalink</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;page&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))})</span>
    <span class="p">}</span>
</code></pre></div>
<p><em>routes</em> est un dictionnaire qui associe à une URI un tuple de longueur 2 qui se décompose comme suit :</p>
<ul>
<li>
<p>La première composante est une fonction : le handler de l'URI</p>
</li>
<li>
<p>La seconde composante est un dictionnaire qui à chaque variable de l'URI associe la liste des valeurs possibles pour cette variable. Dans cet exemple, la variable 'page' (entre accolades dans l'URI) est associée à la liste des entiers de 0 à N-1. Noter qu'il s'agit de Python 3, où <em>range</em> ne retourne pas une liste mais un itérateur, d'où la nécessité d'utiliser <em>list</em> pour convertir cet itérateur en liste. Si l'URI n'accepte pas de variable, alors on passe le dictionnaire vide.</p>
</li>
</ul>
<p>Voici le reste du code, avec les fonctions <em>main</em> et <em>permalink</em>:</p>
<div class="codehilite"><pre class="source"><code><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">pages</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
    <span class="n">template</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">get_template</span><span class="p">(</span><span class="s">&#39;front_page.html&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">template</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">pages</span><span class="o">=</span><span class="n">pages</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">permalink</span><span class="p">(</span><span class="n">page</span><span class="p">):</span>
    <span class="n">max_page</span> <span class="o">=</span> <span class="n">N</span>
    <span class="n">template</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">get_template</span><span class="p">(</span><span class="s">&#39;page.html&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">template</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">max_page</span><span class="o">=</span><span class="n">max_page</span><span class="p">,</span> <span class="n">page</span><span class="o">=</span><span class="n">page</span><span class="p">)</span>
</code></pre></div>
<p>Comme vous pouvez le constater, <em>permalink</em> accepte un paramètre 'page' qui correspond à la variable dans l'URI à laquelle la fonction est associée.</p>
<p>Dans ce code, on suppose qu'on utilise un système de template (jinja2, en l'occurence) et que la variable <em>env</em> est juste un objet qu'on a créé plus tôt qui permet de récupérer facilement nos templates. Voici les templates <em>front_page.html</em> et <em>page.html</em> :</p>
<p>front_page.html</p>
<div class="codehilite"><pre class="source"><code><span class="nt">&lt;p&gt;</span>This website contains the following pages:<span class="nt">&lt;/p&gt;</span>

<span class="nt">&lt;ul&gt;</span>
    {% for p in pages %}
        <span class="nt">&lt;li&gt;&lt;a</span> <span class="na">href=</span><span class="s">&quot;/page/{{ p }}&quot;</span><span class="nt">&gt;</span>Page {{ p }}<span class="nt">&lt;/a&gt;&lt;/li&gt;</span>
    {% endfor %}
<span class="nt">&lt;/ul&gt;</span>
</code></pre></div>
<p>permalink.html</p>
<div class="codehilite"><pre class="source"><code><span class="nt">&lt;p&gt;</span>Hello, I&#39;m page {{ page }}.<span class="nt">&lt;/p&gt;</span>

{% if page &gt; 0 %}
    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;/page/{{ page - 1 }}&quot;</span><span class="nt">&gt;</span>Previous page<span class="nt">&lt;/a&gt;</span> - 
{% endif %}
{% if page <span class="nt">&lt; max_page-1</span> <span class="err">%}</span>
    <span class="err">&lt;</span><span class="na">a</span> <span class="na">href=</span><span class="s">&quot;/page/{{ page + 1 }}&quot;</span><span class="nt">&gt;</span>Next page<span class="nt">&lt;/a&gt;</span>
{% endif %}
</code></pre></div>
<p>Maintenant, mon script Dynastic fonctionne de cette manière : je place les handlers et la variable <em>routes</em> dans un fichier Python nommé <em>get.py</em>, je me déplace dans le dossier où se trouve get.py et je lance la commande :</p>
<pre class="terminal"><code>dynastic generate
</code></pre>
<p>Et boom, magie de la technologie, Dynastic génère le site :</p>
<pre class="terminal"><code>getting combinations for route template: /
Creating files for this route... 1 file created
getting combinations for route template: /page/{page}
Creating files for this route... 10 files created
Done.
</code></pre>
<p>L'arborescence des fichiers créés pour N = 10 ressemble à ça :</p>
<pre class="terminal"><code>www
  |- index.html
  |
  |- page
      |- 0
      |  |- index.html
      |
      |- 1
      |  |- index.html
      |
      |- 2
      |  |- index.html
      |
      |- 3
      |  |- index.html
      |
      |- 4
      |  |- index.html
      |
      |- 5
      |  |- index.html
      |
      |- 6
      |  |- index.html
      |
      |- 7
      |  |- index.html
      |
      |- 8
      |  |- index.html
      |
      |- 9
         |- index.html
</code></pre>
<p>Par défaut, le site est généré dans un dossier appelé 'www' mais je peux choisir un autre nom en l'inscrivant dans une variable nommée <em>dorectory</em> dans get.py</p>
<p>Ce qui se passe à la génération, c'est que pour chaque URI dans <em>routes</em>, Dynastic calcule toutes les combinaisons de valeurs pour les variables. Pour chacune de ces combinaisons, il appelle le handler avec ces valeurs en tant que paramètres et crée un nouveau fichier dont le chemin est calqué sur l'URI formatté avec les valeurs. Dans ce fichier, il écrit le contenu retourné par le handler.</p>
<p>J'ai aussi intégré un serveur http très basique (i.e. j'ai copié-collé le bout de code de la documentation de SimpleHTTPServer) afin de pouvoir tester le blog sur la boucle locale en appelant :</p>
<pre class="terminal"><code>dynastic run
</code></pre>
<h2>Foobuzz</h2>
<p>Dynastic est bien gentil, mais il ne constitue pas vraiment un générateur de site statique dans le sens où j'avais toujours à écrire les handlers, ce qui constitue en fait le gros du travail. Je ne vais pas aller dans les détails sur comment est codé ce blog, mais juste expliquer brièvement les choix que j'ai fait pour stocker et manipuler les données.</p>
<p>J'ai fait le choix d'une stratégie hybride entre :</p>
<ul>
<li>
<p>une base de données SQLite, pour les méta-données comme : date de l'article, catégorie, auteur, titre, etc).</p>
</li>
<li>
<p>des fichiers Markdown sur le disque pour le contenu véritable des articles.</p>
</li>
</ul>
<p>Avoir les méta-données dans une base de données rend triviale des opérations comme obtenir la liste des articles de telle ou telle catégorie, posté dans l'ordre croissant ou décroissant, etc. Il suffit d'effectuer des requêtes SQL.</p>
<p>Avoir le contenu des articles en Markdown sur le disque rend triviale l'écriture et l'édition des articles. Il suffit d'ouvrir le fichier et d'écrire.</p>
<p>L'inconvénient d'une telle approche hybride est qu'elle nécessite de faire attention à la synchronisation entre les entrées de la base de données et les fichiers Markdown. Pour cela, j'ai un autre script qui définit un certain nombre de fonctions bien utiles à la gestion du blog : publication d'un nouvel article, suppression d'un article, ajout d'une catégorie, etc, et qui s'occupe d'une telle synchronisation.</p>
<h2>Liens</h2>
<p>Pour les curieux, voici <a href="https://github.com/foobuzz/dynastic">le dépôt de Dynastic</a>. Pour finir, voici quelques liens sur les modules Python non standards que j'utilise pour générer le blog :</p>
<ul>
<li>
<p><a href="http://jinja.pocoo.org/docs/dev/">jinja2</a>, pour les templates</p>
</li>
<li>
<p><a href="https://pypi.python.org/pypi/Markdown">markdown</a> pour convertir du markdown en html</p>
</li>
<li>
<p><a href="http://pygments.org/">pygments</a> pour la coloration syntaxique du code intégré dans les articles</p>
</li>
</ul>
	
</article>

<div id="comments">

	<p class="post_comment">Something to say? Send your comment in an <a href="mailto:dprosium@gmail.com?Subject=foobuzz_comment" title="dprosium@gmail.com">email to the author</a> (dprosium@gmail.com). If you want it to be published, please specify so in your email. You can specify under what name you want your comment to be published and a link to your website.</p>

	<h2>Comments</h2>

	
	
		No comment yet.

	

</div>



			</div>
			
			<aside>
				<section id="recent">
					<h1>Last articles</h1>

					<ul>
						
							<li><a href="/dynastic">The First Article</a></li>
						
					</ul>
				</section>
				
				<section id="categories">
					<h1>Categories</h1>
					
					<ul>
						
							<li><a href="/cat/python">Python</a></li>
						
							<li><a href="/cat/meta">Meta</a></li>
						
					</ul>
				</section>
			</aside>
		
		</div>
		
		<footer>
			This blog and its articles are licensed under the <a href="https://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International</a> license. This basically means that you can copy, share and remix the articles, provided that you give appropriate credit, indicate if changes were made, and that it is not for commercial use.
		</footer>
	
	</div>
	</body>

</html>