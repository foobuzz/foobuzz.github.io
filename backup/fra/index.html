<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8"> 
		<link rel="stylesheet" type="text/css" href="/static/styles/styles.css">
		<link rel="stylesheet" type="text/css" href="/static/styles/highlight.css">
		<title>Un programme de sauvegarde - Foobuzz</title>
	</head>
	
	<body>
	<div id="main_wrapper">
	
		<header>
			<div id="head_text_wrapper">
				<div id="head_text_bro"></div>
				<div id="head_text">
					<h1><a href="/">Foobuzz</a></h1>
					<p>Programming and other stuff</p>
				</div>
			</div>
		</header>
		
		<nav>
			<ul id="navigation">
				<li><a href="/">Front</a></li><!--
			 --><li><a href="/archives">Archives</a></li><!--
			 --><li><a href="/about">About</a></li>
			</ul>

		 	<ul id="networking">
				<li><a href="https://twitter.com/_foobuzz">Twitter</a></li>
			</ul>
		</nav>
		
		<div id="main">
		
			<div id="content">

				

<article>

	<div class="entete">by Valentin, <span title="2015-07-04T17:44:57Z">July 04 2015</span>, in
		
		<a href="/cat/programming">Programming</a>, 
		
		<a href="/cat/python">Python</a>
		
	</div>

	<div class="i18n">
		
		Langue : <img src="/static/fr.png" alt="français" title="français"> | <a href="/backup" title="Lire en anglais">Read in English</a>
		
	</div>

	<h1><a href="/backup">Un programme de sauvegarde</a></h1>

	<p>J'ai écris un programme pour créer une sauvegarde de mes fichiers. Je voulais qu'il fasse des sauvegardes <a href="http://typesofbackup.com/full-backup/">totales</a>, non incrémentales, et qu'il utilise à son avantage les anciennes sauvegardes déjà faites. L'idée est que vous avez un dossier source que vous voulez copier vers un dossier cible de manière à ce qu'après la sauvegarde, les deux dossiers soient identiques. Par exemple, mes documents sur mon ordinateur portable et leur copie sur mon disque dur externe. Le programme devrait écraser les fichiers déjà présents dans la cible uniquement s'ils ont été modifiés dans la source depuis la dernière sauvegarde, de manière à ce que le processus soit plus rapide que simplement copier - coller le dossier en entier.</p>
<p>Finalement j'ai découvert que Windows a un programme robuste en ligne de commande pour faire ceci (<a href="https://fr.wikipedia.org/wiki/Robocopy">robocopy</a>), mais écrire un programme pour le faire moi-même a été très instructif, du coup j'explique dans cet article comment je m'en suis sorti pour ce problème.</p>
<h2>Algorithme de base</h2>
<p>Voici le premier algorithme auquel j'ai pensé pour ce problème, en pseudo-code :</p>
<pre class="terminal"><code>function backup(source, target):
  for each filename in source:
    loc_path_file = join(source, filename)
    ext_path_file = join(target, filename)
    if loc_path_file.isfile():
      if not exists(ext_path_file):
        copy(loc_path_file, ext_path_file)
      else:
        same = compare_files(loc_path_file, ext_path_file)
        if not same:
          overwrite(loc_path_file, ext_path_file)
    else if loc_path_file.isdirectory():
      if not exists(ext_path_file):
        mkdir(ext_path_file)
      backup(loc_path_file, ext_path_file)

    for each filename in target but not in source:
      delete(join(target, filename))
</code></pre>
<h2>Comparer les fichiers</h2>
<p>J'ai écris le code réel en Python. Pour comparer deux fichiers, j'ai utilisé le module standard filecmp. Il possède la fonction <code>cmp</code> qui retourne un booléen indiquant si deux fichiers sont identiques. Par défaut, cette fonction effectue une comparaison superficielle ; elle utilise les méta-données des fichiers pour dire s'ils sont probablement pareil. La documentation était un peu trop brève à mon goût et je voulais savoir comment ça marchait exactement, alors j'ai regardé le code source et voilà comment ça marche :</p>
<p>Quand il doit comparer deux fichiers, <code>cmp</code> regarde le type (identifié par un entier), la taille (le nombre d'octets) et la date de dernière modification (et qui a une précision de la seconde) pour les deux fichiers. Si ces trois choses sont égales, alors il retourne True. Sinon, si les tailles diffèrents, alors il retourne False. Sinon, il ouvre les deux fichiers et compare leur contenu. En mode non-superficiel, la fonction saute l'étape de comparaison des triplets (type, taille, date de dernière modification).</p>
<p>Notez que par construction de mon programme, il y a une autre méta-donnée qui doit être la même pour les deux fichiers pour qu'ils soient considérés comme identiques : <em>leur chemin</em> (relatif à la racine source ou cible), ce qui inclue le nom du fichier. En effet, depuis le début on compare uniquement des fichiers qui ont le même chemin. Du coup, une comparaison superficielle est largement suffisante. J'imagine difficilement deux fichiers ayant des différences alors qu'ils ont le même chemin, le même type, la même taille et la même <acronym title="Date de Dernière Modification">DDM</acronym>. Et clairement les deux méta-données les plus importantes là-dedans sont le chemin et la DDM. La seule possibilité serait de modifier un des fichiers moins d'une seconde après leur instant commun de dernière modification (car on jour avec une granularité de la seconde) ; et ceci ne va pas arriver car je ne compte pas modifier mes fichiers pendant que j'en fais leur sauvegarde.</p>
<p>Il fallait toujours que je fasse en sorte que cet instant commun de dernière modification arrive. En effet, imaginez que je fais une sauvegarde à l'instant T. Tous les fichiers dans la source ont une DDM de "T moins quelque chose". Quand de nouveaux fichiers sont copiés de la source à la cible, leur DDM dans la cible (dans ce cas, leur date de création) est fixée à ~T. Lors de la prochaine sauvegarde, tous ces fichiers dans la cible auront donc une DDM de ~T. Et pourtant, leur équivalent dans la source qui n'auront pas été modifiés depuis la dernière sauvegarde auront toujours une DDM de "T moins quelque chose". C'est différent de ~T donc la comparaison superficielle échoue.</p>
<p>Étant donné que la sauvegarde ne doit pas altérer les fichier de la source, la seule solution est de modifier la DDM des fichiers copés et de la remplacer par celle des fichiers originaux. C'est logique quand on y pense : on copie les fichiers et leurs métadonnées. en Python, on fait ça avec la fonction <code>utime</code> du module os.</p>
<p>C'est ainsi qu'on fait voyager des fichiers dans l'espace, et dans le temps.</p>
<h2>Renommer des dossiers</h2>
<p>Maintenant imaginez cette situation : vous avez fait une sauvegarde récemment. Dans le dossier source, il y a ce gros dossier, à jour dans la sauvegarde, et qui s'appelle "Blablabla [2015] - Complete ~foo". Vous n'aimez pas ce nom et renommez ce dossier "blablabla_2015_complete_foo", mais vous ne changez absolument rien à son contenu. Dans son état actuel, quand on lui demande de faire un backup, l'algorithme va chercher dans la cible un dossier nommé "blablabla_2015_complete_foo", il ne va pas le trouver, il va donc en créer un tout nouveau avec ce nom et copier les fichiers dedans. À la fin, lorsqu'il fera le ménage, il supprimera le dossier "Blablabla [2015] - Complete ~foo". C'est une perte de temps. Si le programme était plus intelligent, il renommerait "Blablabla [2015] - Complete ~foo" with "blablabla_2015_complete_foo" et aurait fini.</p>
<p>J'ai pensé à la solution suivante :</p>
<p>Quand on doit sauvegarder un dossier "dos1" qui n'existe pas dans la cible, on cherche parmi les dossiers qui existent dans la cible, mais pas dans le source (ceux qu'on devrait supprimer à la fin) et on leur assigne un score basé sur leur ressemblance avec le dossier "dos1". Si on trouve des dossiers dont le score de ressemblance est au-dessus d'un certain seuil, alors on prend celui avec le meilleur score et on le renomme avec le nom du dossier qu'on veut copier. S'il n'y a pas de dossier dans la cible qui n'existe pas dans la source, ou si aucun dossier n'a un score au-dessus du seuil, on en crée un tout nouveau dans la cible. Dans ces deux situations, on a un dossier sous la main pour lancer l'appel récursif.</p>
<p>Il faut que j'explique comment est calculé ce fameux score "de ressemblance". J'ai choisi de le baser sur deux paramètres : le ratio de similarité entre le nom des deux dossiers, et le ratio de similarité entre le nombre de fichiers dans les deux dossiers. Ce dernier est de l'arithmétique basique. Le premier peut être obtenu en Python avec une instance de l'objet SequenceMatcher sur laquelle on appelle la méthode ratio. Je n'ai pas étudié comment marchait cette classe magique, mais j'ai fait quelques tests et suis plutôt satisfait :</p>
<pre class="terminal"><code>&gt;&gt;&gt; from difflib import SequenceMatcher
&gt;&gt;&gt; def similar(a, b):
    """ Returns a ratio indicating the similarity between two strings. """
    return SequenceMatcher(None, a, b).ratio()

&gt;&gt;&gt; similar('Blablabla [2015] - Complete ~foo', 'blablabla_2015_complete_foo')
0.7457627118644068
&gt;&gt;&gt; similar('Blablabla [2015] - Complete ~foo', 'Really nothing [2011] - In common ~bar')
0.42857142857142855
&gt;&gt;&gt; similar('truck', 'Truck')
0.8
&gt;&gt;&gt; similar('truck', 'truck')
1.0
&gt;&gt;&gt; similar('azertyuiopqsdfghjklmwxcvbn', 'abcdefghijklmnopqrstuvwxyz')
0.4230769230769231
&gt;&gt;&gt; similar('some string', 'some other string')
0.7857142857142857
&gt;&gt;&gt; similar('coolcoolcool', 'nopenopenope')
0.25
</code></pre>
<p>Il n'y a pas de risque à renommer des dossiers car dans le pire des cas le dossier qu'on renomme n'a en fait rien à voir avec le dossier source et le programme s'occupera alors de copier et de supprimer les bons fichiers. C'est juste qu'au lieu de créer un nouveau dossier on renomme un qui allait être supprimé et qu'on utilise celui-ci pour la copie.</p>
<p>On ne peut pas faire la même chose avec les fichiers, car il faudrait être sûr que le fichier qu'on renomme est le même que celui qu'on veut copier, ce qui nécessiterait de les comparer, et pour de vrai cette fois étant donné qu'ils n'auraient plus leur chemin identique. Cela prendrait beaucoup trop de temps pour les quelques cas où ça servirait à quelque chose. Pour être honnête je ne sais pas si ça vaut le coup même pour les dossier (il y a un peu de complexité dans le calcul du score de ressemblance).</p>
<h2>Le programme final en Python</h2>
<div class="codehilite"><pre class="source"><code><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">shutil</span><span class="o">,</span> <span class="nn">filecmp</span><span class="o">,</span> <span class="nn">stat</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="kn">as</span> <span class="nn">op</span>
<span class="kn">from</span> <span class="nn">difflib</span> <span class="kn">import</span> <span class="n">SequenceMatcher</span>


<span class="n">THRESHOLD</span> <span class="o">=</span> <span class="mi">6</span>


<span class="k">def</span> <span class="nf">similar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">ratio</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">look_alike</span><span class="p">(</span><span class="n">dir1</span><span class="p">,</span> <span class="n">dir2</span><span class="p">):</span>
    <span class="n">name1</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">dir1</span><span class="p">))</span>
    <span class="n">name2</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">dir2</span><span class="p">))</span>
    <span class="n">sim_names</span> <span class="o">=</span> <span class="n">similar</span><span class="p">(</span><span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">)</span>
    <span class="n">nb_file1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">dir1</span><span class="p">))</span>
    <span class="n">nb_file2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">dir2</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sim_nbfiles</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">nb_file2</span> <span class="o">-</span> <span class="n">nb_file1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nb_file2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
        <span class="n">sim_nbfiles</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">nb_file1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.1</span>
    <span class="k">return</span> <span class="n">sim_names</span> <span class="o">/</span> <span class="n">sim_nbfiles</span>


<span class="k">def</span> <span class="nf">synchronize_timestamps</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">source_stats</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">source_stats</span><span class="o">.</span><span class="n">st_atime</span><span class="p">,</span> <span class="n">source_stats</span><span class="o">.</span><span class="n">st_mtime</span>
    <span class="n">os</span><span class="o">.</span><span class="n">utime</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">backup</span><span class="p">(</span><span class="n">loc_path</span><span class="p">,</span> <span class="n">ext_path</span><span class="p">):</span>
    <span class="n">all_loc_files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">loc_path</span><span class="p">)</span>
    <span class="n">todel</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ext_path</span><span class="p">,</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">ext_path</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">all_loc_files</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">all_loc_files</span><span class="p">:</span>
        <span class="n">loc_path_file</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">loc_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">ext_path_file</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ext_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">loc_path_file</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">op</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ext_path_file</span><span class="p">):</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">loc_path_file</span><span class="p">,</span> <span class="n">ext_path_file</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">filecmp</span><span class="o">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">loc_path_file</span><span class="p">,</span> <span class="n">ext_path_file</span><span class="p">):</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">loc_path_file</span><span class="p">,</span> <span class="n">ext_path_file</span><span class="p">)</span>
            <span class="n">synchronize_timestamps</span><span class="p">(</span><span class="n">loc_path_file</span><span class="p">,</span> <span class="n">ext_path_file</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">loc_path_file</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">op</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ext_path_file</span><span class="p">):</span>
                <span class="n">best</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">best_score</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">todel</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                        <span class="n">score</span> <span class="o">=</span> <span class="n">look_alike</span><span class="p">(</span><span class="n">loc_path_file</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">THRESHOLD</span> <span class="ow">and</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">:</span>
                            <span class="n">best</span> <span class="o">=</span> <span class="n">fname</span>
                            <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
                <span class="k">if</span> <span class="n">best</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">renames</span><span class="p">(</span><span class="n">best</span><span class="p">,</span> <span class="n">ext_path_file</span><span class="p">)</span>
                    <span class="n">todel</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">best</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">ext_path_file</span><span class="p">)</span>
            <span class="n">backup</span><span class="p">(</span><span class="n">loc_path_file</span><span class="p">,</span> <span class="n">ext_path_file</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">todel</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</code></pre></div>
<h2>Résultats</h2>
<p>J'ai testé mon programme en faisant une sauvegarde de ma librairie musciale sur mon disque dur externe connecté via USB. C'est un dossier de 12,5 Go contenant un total de 136 dossiers et 1947 fichiers. J'ai effectué plusieurs sauvegardes successives sans modifier la source entre chaque. Le temps pris par le programme est donc uniquement constitué du temps pris pour <em>comparer</em> la source à la cible. Dans des exemples réels, il faudrait bien sûr ajouter à ça le temps de copie des fichiers nouveaux ou bien mis à jour dans la source.</p>
<p>La première sauvegarde, qui était en fait une pure copie étant donné que c'était la toute première sauvegarde, a pris <strong>17 minutes et 16 secondes</strong>. C'est un peu plus qu'une simple copie faite par Windows, qui a pris 16 minutes et 10 seconds.</p>
<p>J'ai fait une seconde sauvegarde avec les DDM non synchronisées. Cela a pris <strong>12 minutes et 4 secondes</strong>. Il y a un petit gain quand on compare les fichiers plutôt que de les copier, mais cela prend toujours beaucoup de temps car les fichiers doivent être ouvert et lus en entier pour la comparaison.</p>
<p>La troisième sauvegarde a été faite avec les DDM synchronisées, ce qui permet à la comparaison superficielle de réussir. Cela a pris <strong>2,68 secondes</strong>.</p>
<p>C'est une performance moindre que robocopy (moins d'une seconde), mais plutôt pas mal pour un petit truc artisanal.</p>
	
</article>

<div id="comments">

	<p class="post_comment">Something to say? Send your comment in an email to the author at <code>dprosium {at} gmail {dot} com</code></a> (If you want it to be published, please specify so in your email. You can specify under what name you want your comment to be published and a link to your website.</p>

	<h2>Comments</h2>

	
	
		No comment yet.

	

</div>



			</div>
			
			<aside>
				<section id="recent">
					<h1>Last articles</h1>

					<ul>
						
							<li><a href="/backup">A full-backup program</a></li>
						
							<li><a href="/dynastic">The First Article</a></li>
						
					</ul>
				</section>
				
				<section id="categories">
					<h1>Categories</h1>
					
					<ul>
						
							<li><a href="/cat/python">Python</a></li>
						
							<li><a href="/cat/meta">Meta</a></li>
						
							<li><a href="/cat/programming">Programming</a></li>
						
					</ul>
				</section>
			</aside>
		
		</div>
		
		<footer>
			This blog and its articles are licensed under the <a href="https://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International</a> license. This basically means that you can copy, share and remix the articles, provided that you give appropriate credit, indicate if changes were made, and that it is not for commercial use.
		</footer>
	
	</div>
	</body>

</html>